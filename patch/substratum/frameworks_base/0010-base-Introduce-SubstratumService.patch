From 082f7d94d62f1edb04e37cea2afac47331904e14 Mon Sep 17 00:00:00 2001
From: Ivan Iskandar <iiiiskandar14@gmail.com>
Date: Fri, 28 Jul 2017 04:56:45 +0200
Subject: [PATCH 10/24] base: Introduce SubstratumService

This change deprecates ThemeInterfacer, so for testers, please do not
compile ThemeInterfacer with this change!

Change-Id: I8c9f331ca7e4c68c35ea13bed587775ee4abeb30
Signed-off-by: Harsh Shandilya <msfjarvis@gmail.com>

Conflicts:
	core/res/AndroidManifest.xml
---
 Android.mk                                         |    2 +
 .../content/substratum/ISubstratumService.aidl     |  130 +++
 core/java/android/os/FileUtils.java                |    2 +-
 core/java/android/provider/Settings.java           |    7 +
 .../substratum/ISubstratumHelperService.aidl       |    7 +
 core/res/AndroidManifest.xml                       |    1 +
 data/etc/Android.mk                                |    9 +
 data/etc/projekt.substratum.theme.xml              |   25 +
 packages/SubstratumService/Android.mk              |   18 +
 packages/SubstratumService/AndroidManifest.xml     |   25 +
 .../service/SubstratumHelperService.java           |  124 +++
 packages/SystemUI/AndroidManifest.xml              |    3 +
 .../com/android/systemui/SysuiRestartReceiver.java |    9 +-
 services/Android.mk                                |    1 +
 .../com/android/server/substratum/SoundUtils.java  |  236 +++++
 .../server/substratum/SubstratumService.java       | 1090 ++++++++++++++++++++
 services/java/com/android/server/SystemServer.java |    6 +
 17 files changed, 1693 insertions(+), 2 deletions(-)
 create mode 100644 core/java/android/content/substratum/ISubstratumService.aidl
 create mode 100644 core/java/com/android/internal/substratum/ISubstratumHelperService.aidl
 create mode 100644 data/etc/projekt.substratum.theme.xml
 create mode 100644 packages/SubstratumService/Android.mk
 create mode 100644 packages/SubstratumService/AndroidManifest.xml
 create mode 100644 packages/SubstratumService/src/android/substratum/service/SubstratumHelperService.java
 create mode 100644 services/core/java/com/android/server/substratum/SoundUtils.java
 create mode 100644 services/core/java/com/android/server/substratum/SubstratumService.java

diff --git a/Android.mk b/Android.mk
index 59a6820..9551780 100644
--- a/Android.mk
+++ b/Android.mk
@@ -175,6 +175,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/content/pm/IPinItemRequest.aidl \
 	core/java/android/content/pm/IShortcutService.aidl \
 	core/java/android/content/pm/permission/IRuntimePermissionPresenter.aidl \
+    core/java/android/content/substratum/ISubstratumService.aidl \
 	core/java/android/database/IContentObserver.aidl \
 	../av/camera/aidl/android/hardware/ICameraService.aidl \
 	../av/camera/aidl/android/hardware/ICameraServiceListener.aidl \
@@ -381,6 +382,7 @@ LOCAL_SRC_FILES += \
 	core/java/com/android/internal/os/IShellCallback.aidl \
 	core/java/com/android/internal/statusbar/IStatusBar.aidl \
 	core/java/com/android/internal/statusbar/IStatusBarService.aidl \
+	core/java/com/android/internal/substratum/ISubstratumHelperService.aidl \
 	core/java/com/android/internal/textservice/ISpellCheckerService.aidl \
 	core/java/com/android/internal/textservice/ISpellCheckerServiceCallback.aidl \
 	core/java/com/android/internal/textservice/ISpellCheckerSession.aidl \
diff --git a/core/java/android/content/substratum/ISubstratumService.aidl b/core/java/android/content/substratum/ISubstratumService.aidl
new file mode 100644
index 0000000..ad8e77a
--- /dev/null
+++ b/core/java/android/content/substratum/ISubstratumService.aidl
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content.substratum;
+
+interface ISubstratumService {
+
+    /**
+     * Install a list of specified overlay packages
+     *
+     * @param paths Filled in with a list of path names for packages to be installed from.
+     */
+    void installOverlay(in List<String> paths);
+
+    /**
+     * Uninstall a list of specified overlay packages
+     *
+     * @param packages  Filled in with a list of path names for packages to be installed from.
+     * @param restartUi Flag to automatically restart the SystemUI.
+     */
+    void uninstallOverlay(in List<String> packages, boolean restartUi);
+
+    /**
+     * Switch the state of specified overlay packages
+     *
+     * @param packages  Filled in with a list of package names to be switched.
+     * @param enable    Whether to enable the specified overlays.
+     * @param restartUi Flag to automatically restart the SystemUI.
+     */
+    void switchOverlay(in List<String> packages, boolean enable, boolean restartUi);
+
+    /**
+     * Change the priority of a specified list of overlays
+     *
+     * @param packages  Filled in with a list of package names to be reordered.
+     * @param restartUi Flag to automatically restart the SystemUI.
+     */
+    void setPriority(in List<String> packages, boolean restartUi);
+
+    /**
+     * Restart SystemUI
+     */
+    void restartSystemUI();
+
+    /**
+     * Copy Method
+     *
+     * @param source        Path of the source file.
+     * @param destination   Path of the source file to be copied to.
+     */
+    void copy(String source, String destination);
+
+    /**
+     * Move Method
+     *
+     * @param source        Path of the source file.
+     * @param destination   Path of the source file to be moved to.
+     */
+    void move(String source, String destination);
+
+    /**
+     * Create Directory Method
+     *
+     * @param destination   Path of the created destination folder.
+     */
+    void mkdir(String destination);
+
+    /**
+     * Delete Directory Method
+     *
+     * @param destination   Path of the directory to be deleted.
+     * @param withParent    Flag to automatically delete the folder encompassing the folder.
+     */
+    void deleteDirectory(String directory, boolean withParent);
+
+    /**
+     * Apply a specified bootanimation
+     *
+     * @param name  Path to extract the bootanimation archive from.
+     */
+    void applyBootanimation(String name);
+
+    /**
+     * Apply a specified font pack
+     *
+     * @param name  Path to extract the font archive from.
+     */
+    void applyFonts(String pid, String fileName);
+
+    /**
+     * Apply a specified sound pack
+     *
+     * @param name  Path to extract the sounds archive from.
+     */
+    void applySounds(String pid, String fileName);
+
+    /**
+     * Profile Applicator
+     *
+     * @param enable     Filled in with a list of package names to be enabled.
+     * @param disable    Filled in with a list of package names to be disabled.
+     * @param name       Name of the profile to be applied.
+     * @param restartUi  Flag to automatically restart the SystemUI.
+     */
+    void applyProfile(in List<String> enable, in List<String> disable, String name,
+            boolean restartUi);
+
+    /**
+     * Apply a specified shutdownanimation
+     *
+     * @param name  Path to extract the shutdown archive from.
+     *              Use null to clear applied custom shutdown
+     */
+    void applyShutdownAnimation(String name);
+
+}
+
diff --git a/core/java/android/os/FileUtils.java b/core/java/android/os/FileUtils.java
index 50b4f8c..e9a04d4 100644
--- a/core/java/android/os/FileUtils.java
+++ b/core/java/android/os/FileUtils.java
@@ -768,7 +768,7 @@ public class FileUtils {
             return dir.isDirectory() ? dir : null;
         }
 
-        return dir.mkdir() ? dir : null;
+        return dir.mkdirs() ? dir : null;
     }
 
     /**
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 6a5a9c1..aad62e2 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -7381,6 +7381,13 @@ public final class Settings {
         public static final String ADB_PORT = "adb_port";
 
         /**
+         * Force authorize Substratum (or equivalent) frontend calling packages by ThemeInterfacer
+         * The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String FORCE_AUTHORIZE_SUBSTRATUM_PACKAGES = "force_authorize_substratum_packages";
+
+        /**
          * This are the settings to be backed up.
          *
          * NOTE: Settings are backed up and restored in the order they appear
diff --git a/core/java/com/android/internal/substratum/ISubstratumHelperService.aidl b/core/java/com/android/internal/substratum/ISubstratumHelperService.aidl
new file mode 100644
index 0000000..e01474e
--- /dev/null
+++ b/core/java/com/android/internal/substratum/ISubstratumHelperService.aidl
@@ -0,0 +1,7 @@
+package com.android.internal.substratum;
+
+oneway interface ISubstratumHelperService {
+    void applyBootAnimation();
+    void applyShutdownAnimation();
+    void applyProfile(in String name);
+}
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index b44cbb9..5973b9d 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -551,6 +551,7 @@
     <protected-broadcast android:name="org.omnirom.omniswitch.ACTION_HIDE_OVERLAY" />
     <protected-broadcast android:name="com.android.systemui.ACTION_DISMISS_KEYGUARD" />
     <protected-broadcast android:name="android.settings.SHOW_INPUT_METHOD_PICKER" />
+    <protected-broadcast android:name="com.android.systemui.action.RESTART_THEME" />
 
     <!-- ====================================================================== -->
     <!--                          RUNTIME PERMISSIONS                           -->
diff --git a/data/etc/Android.mk b/data/etc/Android.mk
index b2c6840..a00cfcd 100644
--- a/data/etc/Android.mk
+++ b/data/etc/Android.mk
@@ -39,3 +39,12 @@ LOCAL_MODULE_CLASS := ETC
 LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/permissions
 LOCAL_SRC_FILES := $(LOCAL_MODULE)
 include $(BUILD_PREBUILT)
+
+########################
+include $(CLEAR_VARS)
+LOCAL_MODULE := projekt.substratum.theme.xml
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/permissions
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
\ No newline at end of file
diff --git a/data/etc/projekt.substratum.theme.xml b/data/etc/projekt.substratum.theme.xml
new file mode 100644
index 0000000..91fdd66
--- /dev/null
+++ b/data/etc/projekt.substratum.theme.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2016 Project Substratum
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+<permissions>
+    <!-- Limitation permission to block out themes from being visible on stock
+         AOSP, or non-OMS devices. -->
+
+    <!-- This is an alias for projekt.substratum.theme -->
+    <feature name="projekt.substratum.theme" />
+
+</permissions>
diff --git a/packages/SubstratumService/Android.mk b/packages/SubstratumService/Android.mk
new file mode 100644
index 0000000..2469149
--- /dev/null
+++ b/packages/SubstratumService/Android.mk
@@ -0,0 +1,18 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_PROGUARD_ENABLED := disabled
+
+LOCAL_PACKAGE_NAME := SubstratumService
+LOCAL_CERTIFICATE := platform
+LOCAL_PRIVILEGED_MODULE := true
+
+include $(BUILD_PACKAGE)
+
+########################
+include $(call all-makefiles-under,$(LOCAL_PATH))
+
diff --git a/packages/SubstratumService/AndroidManifest.xml b/packages/SubstratumService/AndroidManifest.xml
new file mode 100644
index 0000000..8334f9d
--- /dev/null
+++ b/packages/SubstratumService/AndroidManifest.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="android.substratum.service"
+    android:sharedUserId="android.uid.system"
+    android:versionCode="1"
+    android:versionName="one" >
+
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+
+    <application
+        android:allowBackup="false"
+        android:label="Substratum Service">
+
+        <service android:name="android.substratum.service.SubstratumHelperService"
+                 android:enabled="true"
+                 android:exported="true">
+            <intent-filter>
+                <action android:name="android.substratum.service.SubstratumHelperService" />
+            </intent-filter>
+        </service>
+
+    </application>
+
+</manifest>
diff --git a/packages/SubstratumService/src/android/substratum/service/SubstratumHelperService.java b/packages/SubstratumService/src/android/substratum/service/SubstratumHelperService.java
new file mode 100644
index 0000000..f13c7f1
--- /dev/null
+++ b/packages/SubstratumService/src/android/substratum/service/SubstratumHelperService.java
@@ -0,0 +1,124 @@
+package android.substratum.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.IBinder;
+import android.os.SELinux;
+import android.util.Log;
+
+import com.android.internal.substratum.ISubstratumHelperService;
+
+import java.io.File;
+
+public class SubstratumHelperService extends Service {
+    private static final String TAG = "SubstratumService";
+
+    private final File EXTERNAL_CACHE_DIR =
+            new File(Environment.getExternalStorageDirectory(), ".substratum");
+    private final File SYSTEM_THEME_DIR = new File(Environment.getDataSystemDirectory(), "theme");
+
+    ISubstratumHelperService service = new ISubstratumHelperService.Stub() {
+        @Override
+        public void applyBootAnimation() {
+            if (!isAuthorized(Binder.getCallingUid())) return;
+
+            File src = new File(EXTERNAL_CACHE_DIR, "bootanimation.zip");
+            File dst = new File(SYSTEM_THEME_DIR, "bootanimation.zip");
+            int perms = FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH;
+
+            if (dst.exists()) dst.delete();
+            FileUtils.copyFile(src, dst);
+            FileUtils.setPermissions(dst, perms, -1, -1);
+            SELinux.restorecon(dst);
+            src.delete();
+        }
+
+        @Override
+        public void applyShutdownAnimation() {
+            if (!isAuthorized(Binder.getCallingUid())) return;
+
+            File src = new File(EXTERNAL_CACHE_DIR, "shutdownanimation.zip");
+            File dst = new File(SYSTEM_THEME_DIR, "shutdownanimation.zip");
+            int perms = FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH;
+
+            if (dst.exists()) dst.delete();
+            FileUtils.copyFile(src, dst);
+            FileUtils.setPermissions(dst, perms, -1, -1);
+            SELinux.restorecon(dst);
+            src.delete();
+        }
+
+        @Override
+        public void applyProfile(String name) {
+            if (!isAuthorized(Binder.getCallingUid())) return;
+
+            FileUtils.deleteContents(SYSTEM_THEME_DIR);
+
+            File profileDir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
+                    "/substratum/profiles/" + name + "/theme");
+            if (profileDir.exists()) {
+                File profileFonts = new File(profileDir, "fonts");
+                if (profileFonts.exists()) {
+                    File dst = new File(SYSTEM_THEME_DIR, "fonts");
+                    copyDir(profileFonts, dst);
+                }
+
+                File profileSounds = new File(profileDir, "audio");
+                if (profileSounds.exists()) {
+                    File dst = new File(SYSTEM_THEME_DIR, "audio");
+                    copyDir(profileSounds, dst);
+                }
+
+                File profileBootAnimation = new File(profileDir, "bootanimation.zip");
+                if (profileBootAnimation.exists()) {
+                    File dst = new File(SYSTEM_THEME_DIR, "bootanimation.zip");
+                    FileUtils.copyFile(profileBootAnimation, dst);
+                    int perms = FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH;
+                    FileUtils.setPermissions(dst, perms, -1, -1);
+                }
+
+                File profileShutdownAnimation = new File(profileDir, "shutdownanimation.zip");
+                if (profileShutdownAnimation.exists()) {
+                    File dst = new File(SYSTEM_THEME_DIR, "shutdownanimation.zip");
+                    FileUtils.copyFile(profileShutdownAnimation, dst);
+                    int perms = FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH;
+                    FileUtils.setPermissions(dst, perms, -1, -1);
+                }
+
+                SELinux.restorecon(SYSTEM_THEME_DIR);
+            }
+        }
+
+        private boolean isAuthorized(int uid) {
+            return "android.uid.system:1000".equals(getPackageManager().getNameForUid(uid));
+        }
+
+        private boolean copyDir(File src, File dst) {
+            File[] files = src.listFiles();
+            boolean success = true;
+
+            if (files != null) {
+                for (File file : files) {
+                    File newFile = new File(dst, file.getName());
+                    if (file.isDirectory()) {
+                        success &= copyDir(file, newFile);
+                    } else {
+                        success &= FileUtils.copyFile(file, newFile);
+                    }
+                }
+            } else {
+                // not a directory
+                success = false;
+            }
+            return success;
+        }
+    };
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return service.asBinder();
+    }
+}
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 3089de0..0085092 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -251,6 +251,9 @@
 
                 <data android:scheme="package" />
             </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.systemui.action.RESTART_THEME" />
+            </intent-filter>
         </receiver>
 
         <!-- started from PhoneWindowManager
diff --git a/packages/SystemUI/src/com/android/systemui/SysuiRestartReceiver.java b/packages/SystemUI/src/com/android/systemui/SysuiRestartReceiver.java
index cdeef2f..75de186 100644
--- a/packages/SystemUI/src/com/android/systemui/SysuiRestartReceiver.java
+++ b/packages/SystemUI/src/com/android/systemui/SysuiRestartReceiver.java
@@ -25,12 +25,19 @@ import com.android.internal.messages.nano.SystemMessageProto.SystemMessage;
 public class SysuiRestartReceiver extends BroadcastReceiver {
 
     public static String ACTION = "com.android.systemui.action.RESTART";
+    public static String ACTION_THEME = "com.android.systemui.action.RESTART_THEME";
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        if (ACTION.equals(intent.getAction())) {
+        boolean runAction = ACTION.equals(intent.getAction());
+        boolean runThemeAction = ACTION_THEME.equals(intent.getAction());
+
+        if (runAction) {
             String pkg = intent.getData().toString().substring(10);
             NotificationManager.from(context).cancel(pkg, SystemMessage.NOTE_PLUGIN);
+        }
+
+        if (runAction || runThemeAction) {
             Process.killProcess(Process.myPid());
         }
     }
diff --git a/services/Android.mk b/services/Android.mk
index 5c863b0..8ea6094 100644
--- a/services/Android.mk
+++ b/services/Android.mk
@@ -8,6 +8,7 @@ LOCAL_MODULE := services
 LOCAL_DEX_PREOPT_APP_IMAGE := true
 LOCAL_DEX_PREOPT_GENERATE_PROFILE := true
 LOCAL_DEX_PREOPT_PROFILE_CLASS_LISTING := $(LOCAL_PATH)/profile-classes
+LOCAL_REQUIRED_MODULES := projekt.substratum.theme.xml
 
 LOCAL_SRC_FILES := $(call all-java-files-under,java)
 
diff --git a/services/core/java/com/android/server/substratum/SoundUtils.java b/services/core/java/com/android/server/substratum/SoundUtils.java
new file mode 100644
index 0000000..eb4e84a
--- /dev/null
+++ b/services/core/java/com/android/server/substratum/SoundUtils.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.substratum;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.media.RingtoneManager;
+import android.net.Uri;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.MediaStore;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.io.File;
+import java.util.Arrays;
+
+public class SoundUtils {
+    private static final String TAG = "SubstratumService";
+    private static final String SYSTEM_MEDIA_PATH = "/system/media/audio";
+    private static final String SYSTEM_ALARMS_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "alarms";
+    private static final String SYSTEM_RINGTONES_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "ringtones";
+    private static final String SYSTEM_NOTIFICATIONS_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "notifications";
+    private static final String MEDIA_CONTENT_URI = "content://media/internal/audio/media";
+
+    private static void updateGlobalSettings(ContentResolver resolver, String uri, String val) {
+        Settings.Global.putStringForUser(resolver, uri, val, UserHandle.USER_SYSTEM);
+    }
+
+    public static boolean setUISounds(ContentResolver resolver, String sound_name, String
+            location) {
+        if (allowedUISound(sound_name)) {
+            updateGlobalSettings(resolver, sound_name, location);
+            return true;
+        }
+
+        return false;
+    }
+
+    public static void setDefaultUISounds(ContentResolver resolver, String sound_name,
+                                          String sound_file) {
+        updateGlobalSettings(resolver, sound_name, "/system/media/audio/ui/" + sound_file);
+    }
+
+    // This string array contains all the SystemUI acceptable sound files
+    private static Boolean allowedUISound(String targetValue) {
+        String[] allowed_themable = {
+                "lock_sound",
+                "unlock_sound",
+                "low_battery_sound"
+        };
+
+        return Arrays.asList(allowed_themable).contains(targetValue);
+    }
+
+    private static String getDefaultAudiblePath(int type) {
+        final String name;
+        final String path;
+
+        switch (type) {
+            case RingtoneManager.TYPE_ALARM:
+                name = SystemProperties.get("ro.config.alarm_alert");
+                path = name != null ? SYSTEM_ALARMS_PATH + File.separator + name : null;
+                break;
+            case RingtoneManager.TYPE_NOTIFICATION:
+                name = SystemProperties.get("ro.config.notification_sound");
+                path = name != null ? SYSTEM_NOTIFICATIONS_PATH + File.separator + name : null;
+                break;
+            case RingtoneManager.TYPE_RINGTONE:
+                name = SystemProperties.get("ro.config.ringtone");
+                path = name != null ? SYSTEM_RINGTONES_PATH + File.separator + name : null;
+                break;
+            default:
+                path = null;
+                break;
+        }
+
+        return path;
+    }
+
+    public static boolean setAudible(Context context, File ringtone, File ringtoneCache, int type,
+                                     String name) {
+        final String path = ringtone.getAbsolutePath();
+        final String mimeType = name.endsWith(".ogg") ? "application/ogg" : "application/mp3";
+        ContentValues values = new ContentValues();
+
+        values.put(MediaStore.MediaColumns.DATA, path);
+        values.put(MediaStore.MediaColumns.TITLE, name);
+        values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType);
+        values.put(MediaStore.MediaColumns.SIZE, ringtoneCache.length());
+        values.put(MediaStore.Audio.Media.IS_RINGTONE, type == RingtoneManager.TYPE_RINGTONE);
+        values.put(MediaStore.Audio.Media.IS_NOTIFICATION,
+                type == RingtoneManager.TYPE_NOTIFICATION);
+        values.put(MediaStore.Audio.Media.IS_ALARM, type == RingtoneManager.TYPE_ALARM);
+        values.put(MediaStore.Audio.Media.IS_MUSIC, false);
+
+        Uri uri = MediaStore.Audio.Media.getContentUriForPath(path);
+        Uri newUri = null;
+        Cursor c = context.getContentResolver().query(uri,
+                new String[]{
+                        MediaStore.MediaColumns._ID
+                },
+                MediaStore.MediaColumns.DATA + "='" + path + "'",
+                null, null);
+
+        if (c != null && c.getCount() > 0) {
+            c.moveToFirst();
+            String id = String.valueOf(c.getLong(0));
+            c.close();
+
+            newUri = Uri.withAppendedPath(Uri.parse(MEDIA_CONTENT_URI), id);
+            context.getContentResolver().update(uri, values,
+                    MediaStore.MediaColumns._ID + "=" + id, null);
+        }
+
+        if (newUri == null) {
+            newUri = context.getContentResolver().insert(uri, values);
+        }
+
+        try {
+            RingtoneManager.setActualDefaultRingtoneUri(context, type, newUri);
+        } catch (Exception e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+
+        return true;
+    }
+
+    public static boolean setUIAudible(Context context, File localized_ringtone,
+                                       File ringtone_file, int type, String name) {
+        final String path = ringtone_file.getAbsolutePath();
+
+        final String path_clone = "/system/media/audio/ui/" + name + ".ogg";
+
+        ContentValues values = new ContentValues();
+        values.put(MediaStore.MediaColumns.DATA, path);
+        values.put(MediaStore.MediaColumns.TITLE, name);
+        values.put(MediaStore.MediaColumns.MIME_TYPE, "application/ogg");
+        values.put(MediaStore.MediaColumns.SIZE, localized_ringtone.length());
+        values.put(MediaStore.Audio.Media.IS_RINGTONE, false);
+        values.put(MediaStore.Audio.Media.IS_NOTIFICATION, false);
+        values.put(MediaStore.Audio.Media.IS_ALARM, false);
+        values.put(MediaStore.Audio.Media.IS_MUSIC, true);
+
+        Uri uri = MediaStore.Audio.Media.getContentUriForPath(path);
+        Uri newUri = null;
+        Cursor c = context.getContentResolver().query(uri,
+                new String[]{
+                        MediaStore.MediaColumns._ID
+                },
+                MediaStore.MediaColumns.DATA + "='" + path_clone + "'",
+                null, null);
+
+        if (c != null && c.getCount() > 0) {
+            c.moveToFirst();
+            String id = String.valueOf(c.getLong(0));
+            c.close();
+
+            Log.e(TAG, id);
+            newUri = Uri.withAppendedPath(Uri.parse(MEDIA_CONTENT_URI), id);
+
+            try {
+                context.getContentResolver().update(uri, values,
+                        MediaStore.MediaColumns._ID + "=" + id, null);
+            } catch (Exception e) {
+                Log.d(TAG, "The content provider does not need to be updated.");
+            }
+        }
+
+        if (newUri == null) {
+            newUri = context.getContentResolver().insert(uri, values);
+        }
+
+        try {
+            RingtoneManager.setActualDefaultRingtoneUri(context, type, newUri);
+        } catch (Exception e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+
+        return true;
+    }
+
+    public static boolean setDefaultAudible(Context context, int type) {
+        final String audiblePath = getDefaultAudiblePath(type);
+        if (audiblePath == null) {
+            return false;
+        }
+
+        Uri uri = MediaStore.Audio.Media.getContentUriForPath(audiblePath);
+        Cursor c = context.getContentResolver().query(uri,
+                new String[]{
+                        MediaStore.MediaColumns._ID
+                },
+                MediaStore.MediaColumns.DATA + "='" + audiblePath + "'",
+                null, null);
+
+        if (c != null && c.getCount() > 0) {
+            c.moveToFirst();
+            String id = String.valueOf(c.getLong(0));
+            c.close();
+
+            uri = Uri.withAppendedPath(Uri.parse(MEDIA_CONTENT_URI), id);
+        }
+
+        try {
+            RingtoneManager.setActualDefaultRingtoneUri(context, type, uri);
+        } catch (Exception e) {
+            Log.e(TAG, "", e);
+            return false;
+        }
+
+        return true;
+    }
+}
+
diff --git a/services/core/java/com/android/server/substratum/SubstratumService.java b/services/core/java/com/android/server/substratum/SubstratumService.java
new file mode 100644
index 0000000..cb9caa5
--- /dev/null
+++ b/services/core/java/com/android/server/substratum/SubstratumService.java
@@ -0,0 +1,1090 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.substratum;
+
+import android.annotation.NonNull;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.om.IOverlayManager;
+import android.content.om.OverlayInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.IPackageInstallObserver2;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.Signature;
+import android.content.res.AssetManager;
+import android.content.ServiceConnection;
+import android.content.substratum.ISubstratumService;
+import android.graphics.Typeface;
+import android.media.RingtoneManager;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.SELinux;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.substratum.ISubstratumHelperService;
+import com.android.server.SystemService;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.Throwable;
+import java.util.Arrays;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+public final class SubstratumService extends SystemService {
+
+    private static final String TAG = "SubstratumService";
+    private static final String SUBSTRATUM_PACKAGE = "projekt.substratum";
+    private static final boolean DEBUG = false;
+
+    private static final Signature SUBSTRATUM_SIGNATURE = new Signature(""
+            + "308202eb308201d3a003020102020411c02f2f300d06092a864886f70d01010b050030263124302206"
+            + "03550403131b5375627374726174756d20446576656c6f706d656e74205465616d301e170d31363037"
+            + "30333032333335385a170d3431303632373032333335385a3026312430220603550403131b53756273"
+            + "74726174756d20446576656c6f706d656e74205465616d30820122300d06092a864886f70d01010105"
+            + "000382010f003082010a02820101008855626336f645a335aa5d40938f15db911556385f72f72b5f8b"
+            + "ad01339aaf82ae2d30302d3f2bba26126e8da8e76a834e9da200cdf66d1d5977c90a4e4172ce455704"
+            + "a22bbe4a01b08478673b37d23c34c8ade3ec040a704da8570d0a17fce3c7397ea63ebcde3a2a3c7c5f"
+            + "983a163e4cd5a1fc80c735808d014df54120e2e5708874739e22e5a22d50e1c454b2ae310b480825ab"
+            + "3d877f675d6ac1293222602a53080f94e4a7f0692b627905f69d4f0bb1dfd647e281cc0695e0733fa3"
+            + "efc57d88706d4426c4969aff7a177ac2d9634401913bb20a93b6efe60e790e06dad3493776c2c0878c"
+            + "e82caababa183b494120edde3d823333efd464c8aea1f51f330203010001a321301f301d0603551d0e"
+            + "04160414203ec8b075d1c9eb9d600100281c3924a831a46c300d06092a864886f70d01010b05000382"
+            + "01010042d4bd26d535ce2bf0375446615ef5bf25973f61ecf955bdb543e4b6e6b5d026fdcab09fec09"
+            + "c747fb26633c221df8e3d3d0fe39ce30ca0a31547e9ec693a0f2d83e26d231386ff45f8e4fd5c06095"
+            + "8681f9d3bd6db5e940b1e4a0b424f5c463c79c5748a14a3a38da4dd7a5499dcc14a70ba82a50be5fe0"
+            + "82890c89a27e56067d2eae952e0bcba4d6beb5359520845f1fdb7df99868786055555187ba46c69ee6"
+            + "7fa2d2c79e74a364a8b3544997dc29cc625395e2f45bf8bdb2c9d8df0d5af1a59a58ad08b32cdbec38"
+            + "19fa49201bb5b5aadeee8f2f096ac029055713b77054e8af07cd61fe97f7365d0aa92d570be98acb89"
+            + "41b8a2b0053b54f18bfde092eb");
+
+    private static final Signature SUBSTRATUM_CI_SIGNATURE = new Signature(""
+            + "308201dd30820146020101300d06092a864886f70d010105050030373116301406035504030c0d416e"
+            + "64726f69642044656275673110300e060355040a0c07416e64726f6964310b30090603550406130255"
+            + "53301e170d3137303232333036303730325a170d3437303231363036303730325a3037311630140603"
+            + "5504030c0d416e64726f69642044656275673110300e060355040a0c07416e64726f6964310b300906"
+            + "035504061302555330819f300d06092a864886f70d010101050003818d00308189028181008aa6cf56"
+            + "e3ba4d0921da3baf527529205efbe440e1f351c40603afa5e6966e6a6ef2def780c8be80d189dc6101"
+            + "935e6f8340e61dc699cfd34d50e37d69bf66fbb58619d0ebf66f22db5dbe240b6087719aa3ceb1c68f"
+            + "3fa277b8846f1326763634687cc286b0760e51d1b791689fa2d948ae5f31cb8e807e00bd1eb72788b2"
+            + "330203010001300d06092a864886f70d0101050500038181007b2b7e432bff612367fbb6fdf8ed0ad1"
+            + "a19b969e4c4ddd8837d71ae2ec0c35f52fe7c8129ccdcdc41325f0bcbc90c38a0ad6fc0c604a737209"
+            + "17d37421955c47f9104ea56ad05031b90c748b94831969a266fa7c55bc083e20899a13089402be49a5"
+            + "edc769811adc2b0496a8a066924af9eeb33f8d57d625a5fa150f7bc18e55");
+
+    private static final File SYSTEM_THEME_DIR =
+            new File(Environment.getDataSystemDirectory(), "theme");
+    private static final File SYSTEM_THEME_CACHE_DIR = new File(SYSTEM_THEME_DIR, "cache");
+    private static final File SYSTEM_THEME_FONT_DIR = new File(SYSTEM_THEME_DIR, "fonts");
+    private static final File SYSTEM_THEME_AUDIO_DIR = new File(SYSTEM_THEME_DIR, "audio");
+    private static final File SYSTEM_THEME_RINGTONE_DIR =
+            new File(SYSTEM_THEME_AUDIO_DIR, "ringtones");
+    private static final File SYSTEM_THEME_NOTIFICATION_DIR =
+            new File(SYSTEM_THEME_AUDIO_DIR, "notifications");
+    private static final File SYSTEM_THEME_ALARM_DIR = new File(SYSTEM_THEME_AUDIO_DIR, "alarms");
+    private static final File SYSTEM_THEME_UI_SOUNDS_DIR = new File(SYSTEM_THEME_AUDIO_DIR, "ui");
+    private static final File SYSTEM_THEME_BOOTANIMATION_DIR =
+            new File(SYSTEM_THEME_DIR, "bootanimation.zip");
+    private static final File SYSTEM_THEME_SHUTDOWNANIMATION_DIR =
+            new File(SYSTEM_THEME_DIR, "shutdownanimation.zip");
+
+    private static final Signature[] AUTHORIZED_SIGNATURES = new Signature[]{
+            SUBSTRATUM_SIGNATURE,
+            SUBSTRATUM_CI_SIGNATURE,
+    };
+
+    private static final List<Sound> SOUNDS = Arrays.asList(
+        new Sound(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath(), "/SoundsCache/ui/", "Effect_Tick",
+                "Effect_Tick", RingtoneManager.TYPE_RINGTONE),
+        new Sound(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath(), "/SoundsCache/ui/", "lock_sound",
+                "Lock"),
+        new Sound(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath(), "/SoundsCache/ui/", "unlock_sound",
+                "Unlock"),
+        new Sound(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath(), "/SoundsCache/ui/",
+                "low_battery_sound", "LowBattery"),
+        new Sound(SYSTEM_THEME_ALARM_DIR.getAbsolutePath(), "/SoundsCache/alarms/", "alarm",
+                "alarm", RingtoneManager.TYPE_ALARM),
+        new Sound(SYSTEM_THEME_NOTIFICATION_DIR.getAbsolutePath(), "/SoundsCache/notifications/",
+                "notification", "notification", RingtoneManager.TYPE_NOTIFICATION),
+        new Sound(SYSTEM_THEME_RINGTONE_DIR.getAbsolutePath(), "/SoundsCache/ringtones/",
+                "ringtone", "ringtone", RingtoneManager.TYPE_RINGTONE)
+    );
+
+    private static IOverlayManager mOm;
+    private static IPackageManager mPm;
+    private static boolean isWaiting = false;
+    private static String installedPackageName;
+
+    private Context mContext;
+    private final Object mLock = new Object();
+
+    private static ISubstratumHelperService helperService;
+    private final ServiceConnection helperConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            helperService = ISubstratumHelperService.Stub.asInterface(service);
+            log("Helper service connected");
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            helperService = null;
+            log("Helper service disconnected");
+        }
+    };
+
+    public SubstratumService(@NonNull final Context context) {
+        super(context);
+        mContext = context;
+        if (makeDir(SYSTEM_THEME_DIR)) restoreconThemeDir();
+        publishBinderService("substratum", mService);
+    }
+
+    @Override
+    public void onStart() {
+    }
+
+    @Override
+    public void onSwitchUser(final int newUserId) {
+    }
+
+    private void waitForHelperConnection() {
+        if (helperService == null) {
+            Intent intent = new Intent("android.substratum.service.SubstratumHelperService");
+            intent.setPackage("android.substratum.service");
+            mContext.bindServiceAsUser(intent, helperConnection,
+                    Context.BIND_AUTO_CREATE, UserHandle.SYSTEM);
+
+            while (helperService == null) {
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException e) {
+                    // Shouldn't happen
+                }
+            }
+        }
+    }
+
+    private void endHelperConnection() {
+        mContext.unbindService(helperConnection);
+    }
+
+    private boolean forceAuthorizePackages() {
+        return Settings.Secure.getIntForUser(mContext.getContentResolver(),
+                Settings.Secure.FORCE_AUTHORIZE_SUBSTRATUM_PACKAGES,
+                0, UserHandle.USER_CURRENT) == 1;
+    }
+
+    private boolean doSignaturesMatch(String packageName, Signature signature) {
+        if (packageName != null) {
+              try {
+                  PackageInfo pi = getPm().getPackageInfo(packageName,
+                        PackageManager.GET_SIGNATURES, UserHandle.USER_SYSTEM);
+                  if (pi.signatures != null
+                           && pi.signatures.length == 1
+                           && signature.equals(pi.signatures[0])) {
+                        return true;
+                  }
+              } catch (RemoteException ignored) {
+                  return false;
+              }
+       }
+       return false;
+    }
+
+    private boolean isCallerAuthorized(int uid) {
+        String callingPackage;
+        try {
+            callingPackage = getPm().getPackagesForUid(uid)[0];
+        } catch (RemoteException ignored) {
+            return false;
+        }
+
+        if (TextUtils.equals(callingPackage, SUBSTRATUM_PACKAGE)) {
+            for (Signature sig : AUTHORIZED_SIGNATURES) {
+                if (doSignaturesMatch(callingPackage, sig)) {
+                return true;
+                }
+            }
+        }
+
+       if (forceAuthorizePackages()) {
+            log("\'" + callingPackage + "\' is not an authorized calling package, but the user " +
+                    "has explicitly allowed all calling packages, " +
+                    "validating calling package permissions...");
+            return true;
+        }
+
+        logE("\'" + callingPackage + "\' is not an authorized calling package.");
+        return false;
+    }
+
+
+    private final IBinder mService = new ISubstratumService.Stub() {
+        @Override
+        public void installOverlay(List<String> paths) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            final int packageVerifierEnable = Settings.Global.getInt(
+                    mContext.getContentResolver(),
+                    Settings.Global.PACKAGE_VERIFIER_ENABLE, 1);
+            try {
+                synchronized (mLock) {
+                    PackageInstallObserver installObserver = new PackageInstallObserver();
+                    PackageDeleteObserver deleteObserver = new PackageDeleteObserver();
+                    for (String path : paths) {
+                        installedPackageName = null;
+                        File apkFile = new File(path);
+                        if (apkFile.exists()) {
+                            log("Installer - installing package from path \'" + path + "\'");
+                            isWaiting = true;
+                            Settings.Global.putInt(mContext.getContentResolver(),
+                                    Settings.Global.PACKAGE_VERIFIER_ENABLE, 0);
+                            getPm().installPackageAsUser(
+                                    path,
+                                    installObserver,
+                                    PackageManager.INSTALL_REPLACE_EXISTING,
+                                    null,
+                                    UserHandle.USER_SYSTEM);
+                            while (isWaiting) {
+                                Thread.sleep(1);
+                            }
+
+                            if (installedPackageName != null) {
+                                PackageInfo pi = getPm().getPackageInfo(installedPackageName,
+                                        0, UserHandle.USER_SYSTEM);
+                                if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_HAS_CODE) != 0 ||
+                                        pi.overlayTarget == null) {
+                                    isWaiting = true;
+                                    int versionCode = getPm()
+                                            .getPackageInfo(installedPackageName, 0, UserHandle.USER_SYSTEM)
+                                            .versionCode;
+                                    getPm().deletePackageAsUser(
+                                            installedPackageName,
+                                            versionCode,
+                                            deleteObserver,
+                                            0,
+                                            UserHandle.USER_SYSTEM);
+                                    while (isWaiting) {
+                                        Thread.sleep(1);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                logE("There is an exception when trying to install package", e);
+            } finally {
+                Settings.Global.putInt(mContext.getContentResolver(),
+                        Settings.Global.PACKAGE_VERIFIER_ENABLE, packageVerifierEnable);
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void uninstallOverlay(List<String> packages, boolean restartUi) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                synchronized (mLock) {
+                    PackageDeleteObserver observer = new PackageDeleteObserver();
+                    for (String p : packages) {
+                        if (isOverlayEnabled(p)) {
+                            log("Remover - disabling overlay for \'" + p + "\'...");
+                            switchOverlayState(p, false);
+                        }
+
+                        PackageInfo pi = getPm()
+                                .getPackageInfo(p, 0, UserHandle.USER_SYSTEM);
+                        if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_HAS_CODE) == 0 &&
+                                pi.overlayTarget != null) {
+                            log("Remover - uninstalling \'" + p + "\'...");
+                            isWaiting = true;
+                            getPm().deletePackageAsUser(
+                                    p,
+                                    pi.versionCode,
+                                    observer,
+                                    0,
+                                    UserHandle.USER_SYSTEM);
+                            while (isWaiting) {
+                                Thread.sleep(1);
+                            }
+                        }
+                    }
+                    if (restartUi) {
+                        restartUi();
+                    }
+                }
+            } catch (Exception e) {
+                logE("There is an exception when trying to uninstall package", e);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void switchOverlay(List<String> packages, boolean enable, boolean restartUi) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                synchronized (mLock) {
+                    for (String p : packages) {
+                        log(enable ? "Enabling" : "Disabling" + " overlay " + p);
+                        switchOverlayState(p, enable);
+                    }
+                    if (restartUi) {
+                        restartUi();
+                    }
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void setPriority(List<String> packages, boolean restartUi) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                synchronized (mLock) {
+                    log("PriorityJob - processing priority changes...");
+                    for (int i = 0; i < packages.size() - 1; i++) {
+                        String parentName = packages.get(i);
+                        String packageName = packages.get(i + 1);
+
+                        getOm().setPriority(packageName, parentName,
+                                UserHandle.USER_SYSTEM);
+                    }
+                    if (restartUi) {
+                        restartUi();
+                    }
+                }
+            } catch (RemoteException e) {
+                logE("There is an exception when trying to adjust overlay priority", e);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void restartSystemUI() {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                log("Restarting SystemUI...");
+                restartUi();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void copy(String source, String destination) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                log("CopyJob - copying \'" + source + "\' to \'" + destination + "\'...");
+                File sourceFile = new File(source);
+                if (sourceFile.exists()) {
+                    if (sourceFile.isFile()) {
+                        FileUtils.copyFile(sourceFile, new File(destination));
+                    } else {
+                        copyDir(source, destination);
+                    }
+                } else {
+                    logE("CopyJob - \'" + source + "\' does not exist, aborting...");
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void move(String source, String destination) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                log("MoveJob - moving \'" + source + "\' to \'" + destination + "\'...");
+                File sourceFile = new File(source);
+                if (sourceFile.exists()) {
+                    if (sourceFile.isFile()) {
+                        FileUtils.copyFile(sourceFile, new File(destination));
+                    } else {
+                        copyDir(source, destination);
+                    }
+                    FileUtils.deleteContentsAndDir(sourceFile);
+                } else {
+                    logE("MoveJob - \'" + source + "\' does not exist, aborting...");
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void mkdir(String destination) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                log("MkdirJob - creating \'" + destination + "\'...");
+                makeDir(new File(destination));
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void deleteDirectory(String directory, boolean withParent) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                if (withParent) {
+                    FileUtils.deleteContentsAndDir(new File(directory));
+                } else {
+                    FileUtils.deleteContents(new File(directory));
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void applyBootanimation(String name) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                if (name == null) {
+                    log("Restoring system boot animation...");
+                    clearBootAnimation();
+                } else {
+                    log("Configuring themed boot animation...");
+                    copyBootAnimation(name);
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void applyFonts(String pid, String fileName) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                if (pid == null) {
+                    log("Restoring system font...");
+                    clearFonts();
+                } else {
+                    log("Configuring theme font...");
+                    copyFonts(pid, fileName);
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void applySounds(String pid, String fileName) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                if (pid == null) {
+                    log("Restoring system sounds...");
+                    clearSounds();
+                } else {
+                    log("Configuring theme sounds...");
+                    applyThemedSounds(pid, fileName);
+                }
+                restartUi();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void applyProfile(List<String> enable, List<String> disable, String name,
+                boolean restartUi) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                log("ProfileJob - Applying profile: " + name);
+                waitForHelperConnection();
+                boolean mRestartUi = restartUi;
+
+                boolean oldFontsExists = SYSTEM_THEME_FONT_DIR.exists();
+                boolean oldSoundsExists = SYSTEM_THEME_AUDIO_DIR.exists();
+
+                helperService.applyProfile(name);
+
+                boolean newFontsExists = SYSTEM_THEME_FONT_DIR.exists();
+                boolean newSoundsExists = SYSTEM_THEME_AUDIO_DIR.exists();
+
+                if (oldFontsExists || newFontsExists) {
+                    refreshFonts();
+                }
+
+                if (oldSoundsExists || newSoundsExists) {
+                    refreshSounds();
+                    mRestartUi = true;
+                }
+
+                for (String overlay : disable) {
+                    switchOverlayState(overlay, false);
+                }
+
+                for (String overlay : enable) {
+                    switchOverlayState(overlay, true);
+                }
+
+                if (mRestartUi) {
+                    restartUi();
+                }
+
+                log("ProfileJob - " + name + " successfully applied.");
+            } catch (RemoteException e) {
+                logE("Failed to apply profile", e);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void applyShutdownAnimation(String name) {
+            if (!isCallerAuthorized(Binder.getCallingUid())) return;
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                if (name == null) {
+                    log("Restoring system shutdown animation...");
+                    clearShutdownAnimation();
+                } else {
+                    log("Configuring themed shutdown animation...");
+                    copyShutdownAnimation(name);
+                }
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    };
+
+    private static IOverlayManager getOm() {
+        if (mOm == null) {
+            mOm = IOverlayManager.Stub.asInterface(
+                    ServiceManager.getService(Context.OVERLAY_SERVICE));
+        }
+        return mOm;
+    }
+
+    private static IPackageManager getPm() {
+        if (mPm == null) {
+            mPm = IPackageManager.Stub.asInterface(
+                    ServiceManager.getService("package"));
+        }
+        return mPm;
+    }
+
+    private Context getAppContext(String packageName) {
+        Context ctx = null;
+        try {
+            ctx = mContext.createPackageContext(packageName,
+                    Context.CONTEXT_IGNORE_SECURITY);
+        } catch (NameNotFoundException e) {
+            logE("Failed to get " + packageName + " context");
+        }
+        return ctx;
+    }
+
+    private Context getSubsContext() {
+        return getAppContext(SUBSTRATUM_PACKAGE);
+    }
+
+    private void switchOverlayState(String packageName, boolean enable) {
+        try {
+            getOm().setEnabled(packageName, enable, UserHandle.USER_SYSTEM);
+        } catch (RemoteException e) {
+            logE("There is an exception when trying to switch overlay state", e);
+        }
+    }
+
+    private boolean isOverlayEnabled(String packageName) {
+        boolean enabled = false;
+        try {
+            OverlayInfo info = getOm().getOverlayInfo(packageName, UserHandle.USER_SYSTEM);
+            if (info != null) {
+                enabled = info.isEnabled();
+            } else {
+                logE("Can't find OverlayInfo for " + packageName);
+            }
+        } catch (RemoteException e) {
+            logE("There is an exception when trying to check overlay state", e);
+        }
+        return enabled;
+    }
+
+    private void restartUi() {
+        Intent i = new Intent("com.android.systemui.action.RESTART_THEME");
+        i.setPackage("com.android.systemui");
+        mContext.sendBroadcastAsUser(i, UserHandle.SYSTEM);
+    }
+
+    private void copyBootAnimation(String fileName) {
+        try {
+            waitForHelperConnection();
+            helperService.applyBootAnimation();
+        } catch (Exception e) {
+            logE("There is an exception when trying to apply boot animation", e);
+        }
+    }
+
+    private void clearBootAnimation() {
+        try {
+            if (SYSTEM_THEME_BOOTANIMATION_DIR.exists()) {
+                boolean deleted = SYSTEM_THEME_BOOTANIMATION_DIR.delete();
+                if (!deleted) {
+                    logE("Could not delete themed boot animation");
+                }
+            }
+        } catch (Exception e) {
+            logE("There is an exception when trying to delete themed boot animation", e);
+        }
+    }
+
+    private void copyShutdownAnimation(String fileName) {
+        try {
+            waitForHelperConnection();
+            helperService.applyShutdownAnimation();
+        } catch (Exception e) {
+            logE("There is an exception when trying to apply shutdown animation", e);
+        }
+    }
+
+    private void clearShutdownAnimation() {
+        try {
+            if (SYSTEM_THEME_SHUTDOWNANIMATION_DIR.exists()) {
+                boolean deleted = SYSTEM_THEME_SHUTDOWNANIMATION_DIR.delete();
+                if (!deleted) {
+                    logE("Could not delete themed shutdown animation");
+                }
+            }
+        } catch (Exception e) {
+            logE("There is an exception when trying to delete themed shutdown animation", e);
+        }
+    }
+
+    private void copyFonts(String pid, String zipFileName) {
+        // Prepare local cache dir for font package assembly
+        log("Copy Fonts - Package ID = " + pid + " filename = " + zipFileName);
+
+        File cacheDir = new File(SYSTEM_THEME_CACHE_DIR, "FontCache");
+        if (cacheDir.exists()) {
+            FileUtils.deleteContentsAndDir(cacheDir);
+        }
+
+        boolean created = cacheDir.mkdirs();
+        if (!created) {
+            Log.e(TAG, "Could not create cache directory...");
+            logE("Could not create cache directory");
+        }
+
+        // Copy system fonts into our cache dir
+        copyDir("/system/fonts", cacheDir.getAbsolutePath());
+
+        // Append zip to filename since it is probably removed
+        // for list presentation
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // Copy target themed fonts zip to our cache dir
+        Context themeContext = getAppContext(pid);
+        AssetManager am = themeContext.getAssets();
+        File fontZip = new File(cacheDir, zipFileName);
+        try (InputStream inputStream = am.open("fonts/" + zipFileName)) {
+            FileUtils.copyToFile(inputStream, fontZip);
+        } catch (Exception e) {
+            logE("There is an exception when trying to copy themed fonts", e);
+        }
+
+        // Unzip new fonts and delete zip file, overwriting any system fonts
+        unzip(fontZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+
+        boolean deleted = fontZip.delete();
+        if (!deleted) {
+            logE("Could not delete ZIP file");
+        }
+
+        // Check if theme zip included a fonts.xml. If not, Substratum
+        // is kind enough to provide one for us in it's assets
+        File testConfig = new File(cacheDir, "fonts.xml");
+        if (!testConfig.exists()) {
+            AssetManager subsAm = getSubsContext().getAssets();
+            try (InputStream inputStream = subsAm.open("fonts.xml")) {
+                FileUtils.copyToFile(inputStream, testConfig);
+            } catch (Exception e) {
+                logE("There is an exception when trying to extract default fonts config", e);
+            }
+        }
+
+        // Prepare system theme fonts folder and copy new fonts folder from our cache
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        makeDir(SYSTEM_THEME_FONT_DIR);
+        copyDir(cacheDir.getAbsolutePath(), SYSTEM_THEME_FONT_DIR.getAbsolutePath());
+
+        // Let system know it's time for a font change
+        FileUtils.deleteContentsAndDir(cacheDir);
+        refreshFonts();
+    }
+
+    private void clearFonts() {
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        refreshFonts();
+    }
+
+    private void refreshFonts() {
+        // Set permissions on font files and config xml
+        if (SYSTEM_THEME_FONT_DIR.exists()) {
+            // Set permissions
+            setPermissionsRecursive(SYSTEM_THEME_FONT_DIR,
+                    FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO,
+                    FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH);
+            restoreconThemeDir();
+        }
+
+        // Let system know it's time for a font change
+        SystemProperties.set("sys.refresh_theme", "1");
+        Typeface.recreateDefaults();
+        float fontSize = Settings.System.getFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, 1.0f, UserHandle.USER_CURRENT);
+        Settings.System.putFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, (fontSize + 0.0000001f), UserHandle.USER_CURRENT);
+    }
+
+    private void applyThemedSounds(String pid, String zipFileName) {
+        // Prepare local cache dir for font package assembly
+        log("CopySounds - Package ID = \'" + pid + "\'");
+        log("CopySounds - File name = \'" + zipFileName + "\'");
+
+        File cacheDir = new File(SYSTEM_THEME_CACHE_DIR, "SoundsCache");
+        if (cacheDir.exists()) {
+            FileUtils.deleteContentsAndDir(cacheDir);
+        }
+
+        boolean created = cacheDir.mkdirs();
+        if (!created) {
+            logE("Could not create cache directory");
+        }
+
+        // Append zip to filename since it is probably removed
+        // for list presentation
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // Copy target themed sounds zip to our cache dir
+        Context themeContext = getAppContext(pid);
+        AssetManager am = themeContext.getAssets();
+        File soundsZip = new File(cacheDir, zipFileName);
+        try (InputStream inputStream = am.open("audio/" + zipFileName)) {
+            FileUtils.copyToFile(inputStream, soundsZip);
+        } catch (Exception e) {
+            logE("There is an exception when trying to copy themed sounds", e);
+        }
+
+        // Unzip new sounds and delete zip file
+        unzip(soundsZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+
+        boolean deleted = soundsZip.delete();
+        if (!deleted) {
+            logE("Could not delete ZIP file");
+        }
+
+        clearSounds();
+        makeDir(SYSTEM_THEME_AUDIO_DIR);
+
+        for (Sound sound : SOUNDS) {
+            File soundsCache = new File(SYSTEM_THEME_CACHE_DIR, sound.cachePath);
+
+            if (!(soundsCache.exists() && soundsCache.isDirectory())) {
+                continue;
+            }
+
+            makeDir(new File(sound.themePath));
+
+            File mp3 = new File(SYSTEM_THEME_CACHE_DIR, sound.cachePath + sound.soundPath + ".mp3");
+            File ogg = new File(SYSTEM_THEME_CACHE_DIR, sound.cachePath + sound.soundPath + ".ogg");
+            if (ogg.exists()) {
+                FileUtils.copyFile(ogg,
+                        new File(sound.themePath + File.separator + sound.soundPath + ".ogg"));
+            } else if (mp3.exists()) {
+                FileUtils.copyFile(mp3,
+                        new File(sound.themePath + File.separator + sound.soundPath + ".mp3"));
+            }
+        }
+
+        // Let system know it's time for a sound change
+        FileUtils.deleteContentsAndDir(cacheDir);
+        refreshSounds();
+    }
+
+    private void clearSounds() {
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_AUDIO_DIR);
+        SoundUtils.setDefaultAudible(mContext, RingtoneManager.TYPE_ALARM);
+        SoundUtils.setDefaultAudible(mContext, RingtoneManager.TYPE_NOTIFICATION);
+        SoundUtils.setDefaultAudible(mContext, RingtoneManager.TYPE_RINGTONE);
+        SoundUtils.setDefaultUISounds(mContext.getContentResolver(), "lock_sound", "Lock.ogg");
+        SoundUtils.setDefaultUISounds(mContext.getContentResolver(), "unlock_sound", "Unlock.ogg");
+        SoundUtils.setDefaultUISounds(mContext.getContentResolver(), "low_battery_sound", "LowBattery.ogg");
+    }
+
+    private void refreshSounds() {
+
+        if (!SYSTEM_THEME_AUDIO_DIR.exists()) {
+            return;
+        }
+
+        // Set permissions
+        setPermissionsRecursive(SYSTEM_THEME_AUDIO_DIR,
+                FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO,
+                FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH);
+
+        int metaDataId = getSubsContext().getResources().getIdentifier(
+                "content_resolver_notification_metadata",
+                "string", SUBSTRATUM_PACKAGE);
+
+        for (Sound sound : SOUNDS) {
+            File themePath = new File(sound.themePath);
+
+            if (!(themePath.exists() && themePath.isDirectory())) {
+                continue;
+            }
+
+            File mp3 = new File(themePath, sound.soundPath + ".mp3");
+            File ogg = new File(themePath, sound.soundPath + ".ogg");
+
+            if (ogg.exists()) {
+                if (sound.themePath.equals(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath())
+                        && sound.type != 0) {
+                    SoundUtils.setUIAudible(mContext, ogg, ogg, sound.type, sound.soundName);
+                } else if (sound.themePath.equals(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath())) {
+                    SoundUtils.setUISounds(mContext.getContentResolver(), sound.soundName, ogg
+                            .getAbsolutePath());
+                } else {
+                    SoundUtils.setAudible(mContext, ogg, ogg, sound.type, getSubsContext().getString
+                            (metaDataId));
+                }
+            } else if (mp3.exists()) {
+                if (sound.themePath.equals(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath())
+                        && sound.type != 0) {
+                    SoundUtils.setUIAudible(mContext, mp3, mp3, sound.type, sound.soundName);
+                } else if (sound.themePath.equals(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath())) {
+                    SoundUtils.setUISounds(mContext.getContentResolver(), sound.soundName,
+                            mp3.getAbsolutePath());
+                } else {
+                    SoundUtils.setAudible(mContext, mp3, mp3, sound.type, getSubsContext().getString
+                            (metaDataId));
+                }
+            } else {
+                if (sound.themePath.equals(SYSTEM_THEME_UI_SOUNDS_DIR.getAbsolutePath())) {
+                    SoundUtils.setDefaultUISounds(mContext.getContentResolver(),
+                            sound.soundName, sound.soundPath + ".ogg");
+                } else {
+                    SoundUtils.setDefaultAudible(mContext, sound.type);
+                }
+            }
+        }
+    }
+
+    private void unzip(String source, String destination) {
+        try (ZipInputStream inputStream = new ZipInputStream(
+                new BufferedInputStream(new FileInputStream(source)))) {
+            ZipEntry zipEntry;
+            int count;
+            byte[] buffer = new byte[8192];
+
+            while ((zipEntry = inputStream.getNextEntry()) != null) {
+                File file = new File(destination, zipEntry.getName());
+                File dir = zipEntry.isDirectory() ? file : file.getParentFile();
+
+                if (!dir.isDirectory() && !dir.mkdirs()) {
+                    throw new FileNotFoundException("Failed to ensure directory: " +
+                            dir.getAbsolutePath());
+                }
+
+                if (zipEntry.isDirectory()) {
+                    continue;
+                }
+
+                try (FileOutputStream outputStream = new FileOutputStream(file)) {
+                    while ((count = inputStream.read(buffer)) != -1) {
+                        outputStream.write(buffer, 0, count);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            logE("There is an exception when trying to unzip", e);
+        }
+    }
+
+    private boolean makeDir(File dir) {
+
+        if (dir.exists()) {
+            return dir.isDirectory();
+        }
+
+        if (dir.mkdirs()) {
+            int permissions = FileUtils.S_IRWXU | FileUtils.S_IRWXG |
+                FileUtils.S_IRWXO;
+            SELinux.restorecon(dir);
+            return FileUtils.setPermissions(dir, permissions, -1, -1) == 0;
+        }
+
+        return false;
+    }
+
+    private boolean copyDir(String src, String dst) {
+        File[] files = new File(src).listFiles();
+        boolean success = true;
+
+        if (files != null) {
+            for (File file : files) {
+                File newFile = new File(dst + File.separator +
+                        file.getName());
+                if (file.isDirectory()) {
+                    success &= copyDir(file.getAbsolutePath(),
+                            newFile.getAbsolutePath());
+                } else {
+                    success &= FileUtils.copyFile(file, newFile);
+                }
+            }
+        } else {
+            // not a directory
+            success = false;
+        }
+        return success;
+    }
+
+    void setPermissions(File path, int permissions) {
+        FileUtils.setPermissions(path, permissions, -1, -1);
+    }
+
+    void setPermissionsRecursive(File dir, int file, int folder) {
+        if (!dir.isDirectory()) {
+            setPermissions(dir, file);
+            return;
+        }
+
+        for (File child : dir.listFiles()) {
+            if (child.isDirectory()) {
+                setPermissionsRecursive(child, file, folder);
+                setPermissions(child, folder);
+            } else {
+                setPermissions(child, file);
+            }
+        }
+
+        setPermissions(dir, folder);
+    }
+
+    private boolean restoreconThemeDir() {
+        return SELinux.restoreconRecursive(SYSTEM_THEME_DIR);
+    }
+
+    private void log(String msg) {
+        if (DEBUG) {
+            Log.d(TAG, msg);
+        }
+    }
+
+    private void logE(String msg, Throwable tr) {
+        if (tr != null) {
+            Log.e(TAG, msg, tr);
+        } else {
+            Log.e(TAG, msg);
+        }
+    }
+
+    private void logE(String msg) {
+        logE(msg, null);
+    }
+
+    private static class Sound {
+        String themePath;
+        String cachePath;
+        String soundName;
+        String soundPath;
+        int type;
+
+        Sound(String themePath, String cachePath, String soundName, String soundPath) {
+            this.themePath = themePath;
+            this.cachePath = cachePath;
+            this.soundName = soundName;
+            this.soundPath = soundPath;
+        }
+
+        Sound(String themePath, String cachePath, String soundName, String soundPath, int type) {
+            this.themePath = themePath;
+            this.cachePath = cachePath;
+            this.soundName = soundName;
+            this.soundPath = soundPath;
+            this.type = type;
+        }
+    }
+
+    private class PackageInstallObserver extends IPackageInstallObserver2.Stub {
+        @Override
+        public void onUserActionRequired(Intent intent) throws RemoteException {
+            log("Installer - user action required callback");
+            isWaiting = false;
+        }
+
+        @Override
+        public void onPackageInstalled(String packageName, int returnCode,
+                                       String msg, Bundle extras) {
+            log("Installer - successfully installed \'" + packageName + "\'!");
+            installedPackageName = packageName;
+            isWaiting = false;
+        }
+    }
+
+    private class PackageDeleteObserver extends IPackageDeleteObserver.Stub {
+        @Override
+        public void packageDeleted(String packageName, int returnCode) {
+            log("Remover - successfully removed \'" + packageName + "\'");
+            isWaiting = false;
+        }
+    }
+}
+
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 244cd0a..8ac6304 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -105,6 +105,7 @@ import com.android.server.security.KeyChainSystemService;
 import com.android.server.soundtrigger.SoundTriggerService;
 import com.android.server.statusbar.StatusBarManagerService;
 import com.android.server.storage.DeviceStorageMonitorService;
+import com.android.server.substratum.SubstratumService;
 import com.android.server.telecom.TelecomLoaderService;
 import com.android.server.trust.TrustManagerService;
 import com.android.server.tv.TvInputManagerService;
@@ -642,6 +643,11 @@ public final class SystemServer {
         // Manages Overlay packages
         traceBeginAndSlog("StartOverlayManagerService");
         mSystemServiceManager.startService(new OverlayManagerService(mSystemContext, installer));
+
+        // Substratum system server implementation
+        traceBeginAndSlog("StartSubstratumService");
+        mSystemServiceManager.startService(new SubstratumService(mSystemContext));
+
         traceEnd();
 
         // The sensor service needs access to package manager service, app ops
-- 
2.1.2

